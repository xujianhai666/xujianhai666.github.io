<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cpp on zero.xu blog</title>
    <link>https://xujianhai.fun/tags/cpp/</link>
    <description>Recent content in cpp on zero.xu blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 05 Apr 2020 19:36:11 +0800</lastBuildDate>
    
	<atom:link href="https://xujianhai.fun/tags/cpp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Cpp_basic</title>
      <link>https://xujianhai.fun/posts/cpp_basic/</link>
      <pubDate>Sun, 05 Apr 2020 19:36:11 +0800</pubDate>
      
      <guid>https://xujianhai.fun/posts/cpp_basic/</guid>
      <description>背景 最近准备写 cpp 的一些项目, 学习下不太了解的领域.
基础 fork  1）在父进程中，fork返回新创建子进程的进程ID； 2）在子进程中，fork返回0； 注意printf 这种缓冲区复制的情况
基本数据类型 long long 和 long 和 int的区别
取决于 编译器实现, 编译器根据系统类型的不同做法不同 (16/32/64位系统). long long 肯定是 8字节
 https://blog.csdn.net/w773913/article/details/72810117  类的多态 https://blog.csdn.net/afei__/article/details/82142775
官方定义: 程序运行时，父类指针可以根据具体指向的子类对象，来执行不同的函数 假设Parent 和 child 两个类. Parent 定义了 虚函数和实现, 子类进行了重新的实现. 这个时候会根据具体的实例化指向具体的实现.
- 对存在虚函数的类，编译器会在类中自动生成一个一维的虚函数表: 存储类成员函数指针 - 虚函数表由编译器自动生成和维护 - 被virtual 修饰的成员函数会被编译器放入虚函数表中 - 存在虚函数时，编译器会为对象自动生成一个指向虚函数表的虚指针（通常称之为 vptr 指针） - 虚表是和类对应的，虚表指针是和对象对应的 注意: 父类的构造方法中调用虚函数，不会发生多态。这个和 vptr 的分步初始化有关
为什么呢? 这个和创建子类对象的编译器执行顺序有关
- 对象在创建时，由编译器对 vptr 进行初始化 - 子类的构造会先调用父类的构造函数，这个时候 vptr 会先指向父类的虚函数表 - 子类构造的时候，vptr 会再指向子类的虚函数表 - 对象的创建完成后，vptr 最终的指向才确定 纯虚函数是虚函数再加上 = 0, 抽象类是指包括至少一个纯虚函数的类</description>
    </item>
    
  </channel>
</rss>